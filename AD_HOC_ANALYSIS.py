# -*- coding: utf-8 -*-
"""DigiFoods Loyalty Analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OT_K9E2mt6ZaG4tsbKCPBhQoK-7diokN

<h1><center>A thorough examination of the JSEC loyalty program.</center></h1>

## I. Background
### I. 1. Introduction
Loyalty programs are an excellent approach to persuade customers to continue shopping at or using the services of a company affiliated with the program.

We are tasked with analyzing data provided by the JSEC enterprise in order to assess their 6 month transactional data and parse critical indicators in order to comprehend the transactional data.

### I. 2. Objectives
In this study, I sought to investigate the following customers, as stated:
* Repeat customers who made purchases both this month and last month.
* Customers who are inactive and have not made any purchases this month but had a history of purchase.
* Engaged customers who regularly made purchases every month since their first purchase.

### I. 3. Data 
The provided data consists of a single array of objects that contain the customer's address, birthday, email, name, sex, username, transaction items, transaction price, and transaction date.
"""

dataset_url = "https://github.com/juliusrafaelco/ad-hoc-transaction-files/raw/main/transaction-data-adhoc-analysis.json" # The dataset is uploaded here.

"""## II. Data Gathering
### II. 1. Obtaining Requirements
The dataset is posted to Github for portability, which permits downloading through a direct link; the code below gets or downloads the file from the aforementioned hosting site.
"""

import requests
dataset_content = requests.get(dataset_url).text # Downloads the dataset to dataset_content

"""### II. 2. Checking the Downloaded Dataset
The code below validates the dataset by parsing it to JSON.
"""

import json

raw_transaction_list = None

try:
  raw_transaction_list = json.loads(dataset_content)
  print("✔️ Dataset is valid and loaded.")
except ValueError as e:
  print("❌ Dataset is invalid, cannot be parsed to JSON.")

"""## III. Cleanup and Data Processing
### III. 1. Expanding of Data
As previously stated, the dataset should have a maximum of one transaction item per row; however, after evaluating the dataset, the ``transaction_items`` field of each transaction appears to follow the format of **[item name], (x[item count])**.

Here is an example of multiple transaction items in a single field:

> "transaction_items": "Exotic Extras,Kimchi and Seaweed,(x2);Candy City,Gummy Worms,(x3);Exotic Extras,Beef Chicharon,(x3)"

When there is another transaction item after the item count, a trailing colon occurs. To clear this up, we'll add a new field to the transaction object ``item_quantity`` that contains the number of items purchased, as we'll be creating a transaction object for each transaction item. The code below does said instructions.
"""

from datetime import datetime
import re # Import regex for filtering string data.

cleaned_transaction_list = [] # Initialize a list that we'll append the cleaned data on.

for i in raw_transaction_list:
  transaction_items = i["transaction_items"].split(';')
  for j in transaction_items:
    current_transaction = i.copy()
    product_line = j.split(',')
    product_type = product_line[0]
    product_name = product_line[1]
    product_quantity = int(''.join(re.findall("\d+", product_line[2])))
    current_transaction["product_type"] = product_type
    current_transaction["transaction_items"] = product_name
    current_transaction["item_quantity"] = product_quantity
    current_transaction["transaction_date"] = datetime.strptime(current_transaction["transaction_date"], "%Y/%m/%d")
    cleaned_transaction_list.append(current_transaction)

print("✔️ Data expanded, cleaned transaction objects: " + str(len(cleaned_transaction_list)) +
      ", original transaction objects count: " + str(len(raw_transaction_list)))

"""### III. 2. Creation of Dataframe
First we need to import the required libraries for handling the data. The code below does it.
"""

from matplotlib import pyplot as plt
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

"""The dataframe for the for the entire dataset is created and outputted using the code below."""

dataframe = pd.DataFrame(data=cleaned_transaction_list)
dataframe # Print the dataframe.

"""The code below generates a distinct list for repeaters based on their purchase of the most recent month in the dataset and the month before it. In other words, clients who made transactions both in June and May."""

last_transaction = max(data["transaction_date"] for data in cleaned_transaction_list) # Get the latest month in the dataset first.

newest_transactional_month = last_transaction.month
the_month_before = newest_transactional_month - 1

transactions_of_current_month = dataframe[dataframe["transaction_date"].dt.month == newest_transactional_month] # Get the transactions for the current month.
transactions_of_last_month = dataframe[dataframe["transaction_date"].dt.month == the_month_before]
repeaters_dataframe = transactions_of_current_month[transactions_of_current_month["username"].isin(transactions_of_last_month["username"])]

"""The code below creates a dataframe for inactive customers."""

transactions_not_of_the_current_month = dataframe[~dataframe["username"].isin(transactions_of_current_month["username"])]

"""The code below creates a dataframe for engaged customers."""

sorted_df = dataframe.sort_values(by=["transaction_date"])

#print(sorted_df["transaction_date"].dtypes)
#print(sorted_df["transaction_date"].diff())

                                                                                              # .diff() timedelta64 which has months but series
                                                                                                              # .dt TimedeltaProperties doesnt have months
engaged_transactions = sorted_df.groupby(["username"]).filter(lambda x: (x["transaction_date"].diff().apply(lambda y: y / np.timedelta64(1, "M"))).all())

"""Sales analysis dataframes are generated via the codes below."""

from datetime import datetime, timedelta
import calendar, collections

items_and_date = dataframe[["transaction_items", "transaction_date", "item_quantity"]]
items_and_date["transaction_date"] = pd.PeriodIndex(items_and_date["transaction_date"], freq="M")
items_and_date["period_total"] = items_and_date.groupby(["transaction_items", "transaction_date"])["item_quantity"].transform('sum')
items_and_date = items_and_date.drop_duplicates(subset=["transaction_items", "transaction_date"])
dates = items_and_date["transaction_date"].drop_duplicates().to_list()
product = items_and_date["transaction_items"].drop_duplicates().to_list()

def nested_dict():
    return collections.defaultdict(nested_dict)

cleaned_products = nested_dict()

for i in dates:
  date_exp = nested_dict()
  for index, row in items_and_date.iterrows():
    if row["transaction_date"] == i:
      if not date_exp[row["transaction_items"]]:
        date_exp[row["transaction_items"]] = 0
      date_exp[row["transaction_items"]] += abs(row["period_total"])
  cleaned_products[i] = date_exp
transposed_items_and_date = pd.DataFrame(cleaned_products)

# Now create monthly value of each product dataframe.
items_and_date = dataframe[["transaction_items", "transaction_date", "transaction_value"]]
items_and_date["transaction_date"] = pd.PeriodIndex(items_and_date["transaction_date"], freq="M")
items_and_date["period_total"] = items_and_date.groupby(["transaction_items", "transaction_date"])["transaction_value"].transform('sum')
items_and_date = items_and_date.drop_duplicates(subset=["transaction_items", "transaction_date"])

product_values = nested_dict()

for i in dates:
  date_exp = nested_dict()
  for index, row in items_and_date.iterrows():
    if row["transaction_date"] == i:
      if not date_exp[row["transaction_items"]]:
        date_exp[row["transaction_items"]] = 0
      date_exp[row["transaction_items"]] += abs(row["period_total"])

  product_values[i] = date_exp

product_values_dataframe = pd.DataFrame(product_values)

# Get count per item type
items_and_date = dataframe[["product_type", "transaction_date", "item_quantity"]]
items_and_date["transaction_date"] = pd.PeriodIndex(items_and_date["transaction_date"], freq="M")
items_and_date["period_total"] = items_and_date.groupby(["product_type", "transaction_date"])["item_quantity"].transform('sum')
items_and_date = items_and_date.drop_duplicates(subset=["product_type", "transaction_date"])

item_type_val = nested_dict()

for i in dates:
  date_exp = nested_dict()
  for index, row in items_and_date.iterrows():
    if row["transaction_date"] == i:
      if not date_exp[row["product_type"]]:
        date_exp[row["product_type"]] = 0
      date_exp[row["product_type"]] += abs(row["period_total"])

  product_values[i] = date_exp

count_per_type = pd.DataFrame(product_values)

"""The code below creates dataframes for the overall data of the customers."""

engaged_transactions["count"] = 1
engaged_transactions["transaction_date"] = pd.PeriodIndex(engaged_transactions["transaction_date"], freq="M")
engaged_transactions["period_total"] = engaged_transactions.groupby(["transaction_date"], as_index=False)["count"].transform('sum')
engaged_transactions_period = engaged_transactions.drop_duplicates(subset=["transaction_date"])
transactions_per_month = engaged_transactions_period[["transaction_date", "period_total"]]
transactions_per_month = transactions_per_month.set_index("transaction_date")
transactions_per_month = transactions_per_month.rename(columns = {"period_total" : "Enaged Customers"})

transactions_not_of_the_current_month["count"] = 1
transactions_not_of_the_current_month["transaction_date"] = pd.PeriodIndex(transactions_not_of_the_current_month["transaction_date"], freq="M")
transactions_not_of_the_current_month["period_total"] = transactions_not_of_the_current_month.groupby(["transaction_date"], as_index=False)["count"].transform('sum')
transactions_not_of_the_current_month_period = transactions_not_of_the_current_month.drop_duplicates(subset=["transaction_date"])
transactions_not_of_the_current_month_period = transactions_not_of_the_current_month_period.set_index("transaction_date")

new_transactions_per_month = transactions_per_month.join(transactions_not_of_the_current_month_period["period_total"])
new_transactions_per_month = new_transactions_per_month.fillna(0)
new_transactions_per_month["period_total"] = new_transactions_per_month["period_total"].astype(int)
new_transactions_per_month = new_transactions_per_month.rename(columns = {"period_total" : "Inactive Customers"})

# Add repeaters_dataframe
repeaters_dataframe["count"] = 1
repeaters_dataframe["transaction_date"] = pd.PeriodIndex(repeaters_dataframe["transaction_date"], freq="M")
repeaters_dataframe["period_total"] = repeaters_dataframe.groupby(["transaction_date"], as_index=False)["count"].transform('sum')
repeaters_dataframe_period = repeaters_dataframe.drop_duplicates(subset=["transaction_date"])
repeaters_dataframe_period = repeaters_dataframe_period.set_index("transaction_date")

new_transactions_per_month = new_transactions_per_month.join(repeaters_dataframe_period["period_total"])
new_transactions_per_month = new_transactions_per_month.fillna(0)
new_transactions_per_month["period_total"] = new_transactions_per_month["period_total"].astype(int)
new_transactions_per_month = new_transactions_per_month.rename(columns = {"period_total" : "Repeating Customers"})
new_transactions_per_month = new_transactions_per_month.fillna("No Data")

"""## IV. Data Analysis
### IV. 1. Repeaters
Repeaters are new clients who have the potential to become involved customers. The code below prints a table for the repeaters.
"""

repeaters_dataframe

"""Now it is important to understand what makes consumers return for more; it might be a specific product or anything; the code below outputs which goods are purchased by repeat customers."""

repeaters_purchases = repeaters_dataframe[["transaction_items", "item_quantity"]]
repeaters_purchases = repeaters_purchases.sort_values(by="item_quantity")
repeaters_purchases = repeaters_purchases.groupby('transaction_items')['item_quantity'].sum()
repeaters_purchases_plot = repeaters_purchases.plot.pie(y='item_quantity', figsize=(10, 10), ylabel='Most bought products by the Repeaters', labeldistance=0.8, autopct='%.2f')
repeaters_purchases_plot

"""### IV. 2. Inactive
Customers who have not made any purchases this month are considered inactive; the code below displays a table of all their transactions.
"""

transactions_not_of_the_current_month = transactions_not_of_the_current_month.sort_values(by="transaction_date")
transactions_not_of_the_current_month

"""### IV. 3. Engaged
The code below displays which clients have had a buying streak every month from their initial purchase.

"""

engaged_transactions

"""### IV. 4. General Customer Data
The code below displays the total number of repeaters, engaged, inactive, and monthly transactions.

"""

# transactions_not_of_the_current_month_period
# transactions_per_month
new_transactions_per_month

"""### IV. 5. Sales Data
The sales values of goods in the dataset below are evaluated. This indicates how many times a product is purchased each month.
"""

transposed_items_and_date

"""The code below demonstrates how the monthly value of each product is calculated."""

product_values_dataframe

"""The code below displays a table detailing the product type and its monthly purchases."""

count_per_type